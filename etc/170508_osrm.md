## OSRM Compile

## OSRM이란
> Modern C++ routing engine for shortest paths in road networks.
그냥 짧은 경로를 찾아주는 모던 C++ 라우팅 엔진이라는거다.

현재 다니는 회사에서 경로 트래킹에 사용하는 라우팅 엔진이 이것인데, 이전까진 이걸 OSRM쪽에서 직접 컴파일한 API서버에서 요청을 보내 사용했지만 이게 또 불안정해서 자꾸 요청이 빈 요청이 오거나 아예 요청이 안먹는 경우가 생기는 바람에 결국 자체적으로 컴파일 해서 라우팅 서버를 만들어야 했다.

## 단계
OSRM의 컴파일 과정에는 총 2가지 과정(명령어)가 있다.

osrm-extract, osrm-contract

osrm-extract는 말그대로 맵데이터가 있는 *.osm.pbf 같은 파일에서 *.osrm, *.osrm.* 같은 여러 데이터 파일들을 추출하는 과정이고,

osrm-contract는 위 과정에서 나온 컴파일 결과를 라우팅 엔진이 짧은 시간 내에 최단 경로를 찾을 수 있도록 하는 데이터로 다시 만들어주는 역할을 한다.

위 2가지 과정이 끝나면 osrm-route 라는 명령어로 API처럼 사용이 가능하다.

## 조심해야하는점

이 두가지 과정은 전부 CPU사용량과 메모리 사용량이 엄청나서 컴파일 하는 인스턴스(서버)의 사양이 중요하다. 물론 딸리는 사양에서도 컴파일이 되도록 스왑메모리 설정을 하면 되긴 하지만 엄청나게 긴 시간이 걸린다.

t2.large 인스턴스에서 32gb짜리 planet.osm.pbf파일의 컴파일 시간은 90일이 넘었지만, r4.4xlarge 인스턴스에서의 컴파일 시간은 24시간 약간 안되서 끝난다.

게다가 스왑메모리를 쓰면 더군다나 느린 컴파일이 더 느려져서 빠른컴파일이 필요하다면 스왑메모리를 쓰지말고 컴파일 하는것을 추천한다.

거기에 맵데이터를 추출하게 되면 원래 파일 이었던 osm.pbf 파일의 용량보다 10배 정도 커지기 때문에 디스크 용량을 잘 확보하고 컴파일 하는것도 중요하다. 생각 안하고 해버리면 하는 도중에 디스크 부족으로 컴파일이 중단되어 다시 처음부터 해야하기 때문이다.

## 참고할점

전에 docker이미지로 osrm 컴파일 환경을 구축해서 배포하는데, osrm자체를 컴파일 할 시간이 줄어서 훨씬 나으니 시간이 부족하다면 docker이미지를 사용해보는것도 좋다.

참고로 메모리가 적으면 bad_alloc에러가 마구마구 터지므로 처음부터 그냥 메모리를 여유롭게 잡는편이 정신건강에 유용하다.

현재 이걸쓰는 시점에서 컴파일에 사용하는 세팅은 메모리 120G에 스왑 75G를 사용하고 있다.
